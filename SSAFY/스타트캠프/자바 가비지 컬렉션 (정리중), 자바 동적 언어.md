## Jconsole로 알아보는 JVM 메모리 구조
1. jconsole을 통해 현재 실행되는 자바 프로그램의 cpu 사용량, 메모리 사용량, 활성 쓰레드 개수 등을 모니터링 할 수 있다. (실행 : 자바 폴더/bin/jconsole or cmd에 jconsole 입력)
2. jvm 메모리는 5가지 영역 존재 (os 프로세스 메모리 구조 떠올리면 이해 쉬움)
3. stack's' (여러 개의 스택 ; 쓰레드 당 한 개의 스택 존재) : 메서드를 위한 정보가 저장됨, 메서드가 실행되면 stack frame을 stack 영역에 생성함. 이 프레임 안에 local variable, this(자신 객체 포인터) 등의 메서드 정보 저장됨
4. heap (객체를 저장하는 곳 ; 버전에 따라 조금씩 달라지긴 하지만, 일반적으로 3가지 영역으로 구분됨. eden(new generation) + survival area(young generation; s1, s2 또는 s0, s1과 같이 칭해짐) + old generation ; eden과 survival area까지 합해서 young generation이라고 함
	1. 처음에 생성한 객체는 eden에 쌓임. 
	2. eden이 가득 차면 minor gc가 돌면서 dangled되어있지 않은 객체를 s1로 옮김(eden을 비움)
	3. s1이 가득 차면 s2로 유효 객체를 옮김 (이게 반복되면서 각 객체의 age bit++)
	4. stop-the-world : 가비지 컬렉션이 돌게 되면 모든 쓰레드가 잠시 동작을 멈춘다. 이를 stop-the-world가 발생한다고 칭한다. -> old generation에서는 garbage collection이 동작하는 원리가 mark & sweep 방식으로 동작한다고 한다. 여기서는 죽은 객체를 체크하여 sweep하고 메모리 영역을 compact하게 재배치한다.

- 요즘은 모든 영역에서 g1 gc가 돈다. (병렬적으로 수행되므로 매우 빠르게 수행된다. == stop-the-world가 최소화된다.)

예를 들어, `MyType m = new Type();`를 선언하면, 변수 m은 hashcode로 변환되어 stack에 저장된다. 따라서 hashcode는 int type이라서 'm'은 4 byte로 구성되어 stack의 해당 메서드의 스택 프레임에 박힌다.

가상 메모리 주소 방식으로 이용하여 stack frame에 가상 메모리 주소(해시코드=reference)가 저장되고, 이를 관리하는 가상 메모리 테이블은 heap에서 관리한다. 즉, 매핑되는 '실제' 해당 객체의 힙 주소를 heap 내의 테이블에서 관리하고, 여기서 얻은 주소값을 통해 힙 메모리 상의 객체에 접근한다. (즉, new 키워드는 return으로 hashcode가 반환됨)

- 자바가 포인터를 사용하지 않는 이유 : 자바는 가비지 컬렉션을 사용하기 때문에 포인터를 사용자가 사용할 수 없게 만들었다. (메모리 주소를 직접 선언해버리면 가비지 컬렉션이 돌 수 없으므로)

객체를 직접 접근하려면 느리다. `.`을 이용하여 객체에 접근하려면 느리기 때문에, 자주 사용되는 값은 로컬 변수에 할당하여 사용하자. 
(대표적인 예시가 `for (int i = 0; i < arr.length; i++)` 이다. loop마다 `arr.length`에 계속 접근해야 하므로 성능에 영향 O. 자바8 버전부터는 static object와 final을 heap에서 관리함(7버전까지는 method area에서 관리하다가, framework 돌리니까 자꾸 out of memory가 되어서 바꾼거임) : final 영역 안에 string literal 을 관리함. 힙 영역이기 때문에 가비지 컬렉션 대상이 됨. 이렇게 static object와 같은 것들을 관리하는 곳에 meta space라고 부름(과거에는 permanent area라고 불렀었음)

- method area (== class area)

class metadata

- pc register (pc)
- native stack (c 또는 c++ 코드를 불러와서 관리하는 영역)

### g1 gc는 아래 링크 참고
https://programmer7895.tistory.com/86

---
자바는 동적 언어이다. (이게 아주 중요하다)
- 자바는 클래스를 동적으로 로딩한다.	
	- jvm에는 실행중인 필요한 class 코드만 load된다. (변할 수 있으니까)
	- 따라서 (이론적으로) 자바는 서버를 종료하지 않고도 클래스를 변경하여 런타임에서 변경을 바로 반영할 수 있다. 왜냐? 클래스를 동적으로 로드하니까.
- 메모리 할당을 동적으로 한다.
- 메서드 바인딩(binding)을 동적으로 한다. [참고](https://hsik0225.github.io/java/2020/12/17/Static-Override/)
	- dynamic linking & dynamic binding 시점이 C++과 다르다. 왜냐? 자바는 클래스를 동적으로 로딩하니까. C++은 링킹을 컴파일 타임에 해 둔다. 자바는 컴파일 타임에 링킹을 못한다. 다이나믹하게 클래스를 로딩하니까. 자바는 static linking을 클래스 로딩때 한다. 그리고 메서드 호출때 dynamic linking이 일어난다. 따라서 자바에서는 static은 virtual invokation이 안된다. static은 클래스 로드할 때 링킹이 일어나므로 스태틱 메서드 오버라이딩은 의미가 없다. (`class A`와 `class subA extends A`가 있을 때, A의 static method인 hello()메서드와 이를 subA에서 hello()를 오버라이드 하여 재정의하여도 subA.hello()를 호출하면 A.hello()가 호출된다. 왜냐하면 정적 메서드는 클래스 로딩때 하니까.) 이렇게 동작하기 때문에 자바는 느리다. <- 객체지향을 구현하기 위해 다이나믹하게 구현하였다.
- 변화된 것을 바로바로 반영하기 위해 위처럼 만들었다. 기본적으로 JIT compiler를 통해 최적화를 진행한다 하더라도, 어느정도 느린 이유는 위처럼 동적으로 구현되어있기 때문이다.

---

