## 인코딩에 대한 간단한 이야기
 1. 처음에 미국에서 컴퓨터를 만들었으니, 영어 문자를 숫자로 변환한 코드인 아스키 코드로 컴퓨터 인코딩이 시작되었다.
 2. 이후 아스키 코드에 국제 규격에 맞게 일부 특수 기호들(pound 등)을 추가한 인코딩 코드가 ISO-8859-1가 등장하였다.
 3. 한글이 추가된 인코딩이 EUC-KR, KSC-5601, UTF-8, 이 중에서 UTF-8을 가장 많이 씀(UTF-8을 가장 많이 사용하는 이유는 비용 문제임.
 4. 컴퓨터 세상 속에서 영어가 가장 메인으로 사용되는데, 네트워크 통신 효율을 위해서는 영어의 각 알파벳을 1 byte로 사용하기 위해 utf-8을 메인으로 사용하고 있음; 한글은 초성, 중성, 종성까지 있어야 해서 UTF-8에서는 3 byte로 한 글자가 구성됨, UTF-16에서 한글은 2byte)
 5. 참고로, JVM에서는 기본적으로 UTF-16을 사용하고 있음
 6. 대부분 UTF-8, 또는 해봤자 UTF-16을 사용하는데, 중국의 한자는 너무너무너무 많아서 UTF-24를 사용한다고 함.

<JVM이 UTF-16을 기본으로 사용하는 이유> [출처](https://lordofkangs.tistory.com/86)

- 윈도우는 기본적으로 MS사가 자체 개발한 EUC-KR의 확장형인 MS949 인코딩 방식을 사용한다.
- 영어를 주로 쓰는 국가는 UTF-16방식은 굉장한 메모리 낭비이다. 따라서 UTF-8이 만들어진 것이다.
- 하지만 UTF-8은 8bit를 넘어가는 문자를 구분하기 위해, '구분자'가 추가된다. 8bit를 넘어가는 문자는 대표적으로 한글이다.
- 즉, 영어 등 아스키코드가 주로 사용되는 환경에서는 UTF-8이 유리할 수 있지만 다양한 문자가 사용되는 공간이라면 메모리 효율이 떨어진다.
- UTF-8 인코딩은 헤더규칙이 있기에 변환과정이 필요하여 성능도 떨어진다.
- 유니코드 문자표는 16bit를 기준으로 설정되어 있기에 UTF-16 인코딩 방식은 변환과정이 필요없다.
- 그러므로 JVM은 문자나 문자열을 메모리에 저장할 때, UTF-16 인코딩 방식을 사용하여 저장한다.

## Jconsole로 알아보는 JVM 메모리 구조
1. jconsole을 통해 현재 실행되는 자바 프로그램의 cpu 사용량, 메모리 사용량, 활성 쓰레드 개수 등을 모니터링 할 수 있다. (실행 : 자바 폴더/bin/jconsole or cmd에 jconsole 입력)
2. jvm 메모리는 5가지 영역 존재 (os 프로세스 메모리 구조 떠올리면 이해 쉬움)
3. stack's' (여러 개의 스택 ; 쓰레드 당 한 개의 스택 존재) : 메서드를 위한 정보가 저장됨, 메서드가 실행되면 stack frame을 stack 영역에 생성함. 이 프레임 안에 local variable, this(자신 객체 포인터) 등의 메서드 정보 저장됨
4. heap (객체를 저장하는 곳 ; 버전에 따라 조금씩 달라지긴 하지만, 일반적으로 3가지 영역으로 구분됨. eden(new generation) + survival area(young generation; s1, s2 또는 s0, s1과 같이 칭해짐) + old generation ; eden과 survival area까지 합해서 young generation이라고 함
	1. 처음에 생성한 객체는 eden에 쌓임. 
	2. eden이 가득 차면 minor gc가 돌면서 dangled되어있지 않은 객체를 s1로 옮김(eden을 비움)
	3. s1이 가득 차면 s2로 유효 객체를 옮김 (이게 반복되면서 각 객체의 age bit++)
	4. stop-the-world : 가비지 컬렉션이 돌게 되면 모든 쓰레드가 잠시 동작을 멈춘다. 이를 stop-the-world가 발생한다고 칭한다. -> old generation에서는 garbage collection이 동작하는 원리가 mark & sweep 방식으로 동작한다고 한다. 여기서는 죽은 객체를 체크하여 sweep하고 메모리 영역을 compact하게 재배치한다.

- 요즘은 모든 영역에서 g1 gc가 돈다. (병렬적으로 수행되므로 매우 빠르게 수행된다. == stop-the-world가 최소화된다.)

예를 들어, `MyType m = new Type();`를 선언하면, 변수 m은 hashcode로 변환되어 stack에 저장된다. 따라서 hashcode는 int type이라서 'm'은 4 byte로 구성되어 stack의 해당 메서드의 스택 프레임에 박힌다.

가상 메모리 주소 방식으로 이용하여 stack frame에 가상 메모리 주소(해시코드=reference)가 저장되고, 이를 관리하는 가상 메모리 테이블은 heap에서 관리한다. 즉, 매핑되는 '실제' 해당 객체의 힙 주소를 heap 내의 테이블에서 관리하고, 여기서 얻은 주소값을 통해 힙 메모리 상의 객체에 접근한다. (즉, new 키워드는 return으로 hashcode가 반환됨)

- 자바가 포인터를 사용하지 않는 이유 : 자바는 가비지 컬렉션을 사용하기 때문에 포인터를 사용자가 사용할 수 없게 만들었다. (메모리 주소를 직접 선언해버리면 가비지 컬렉션이 돌 수 없으므로)

객체를 직접 접근하려면 느리다. `.`을 이용하여 객체에 접근하려면 느리기 때문에, 자주 사용되는 값은 로컬 변수에 할당하여 사용하자. 
(대표적인 예시가 `for (int i = 0; i < arr.length; i++)` 이다. loop마다 `arr.length`에 계속 접근해야 하므로 성능에 영향 O. 자바8 버전부터는 static object와 final을 heap에서 관리함(7버전까지는 method area에서 관리하다가, framework 돌리니까 자꾸 out of memory가 되어서 바꾼거임) : final 영역 안에 string literal 을 관리함. 힙 영역이기 때문에 가비지 컬렉션 대상이 됨. 이렇게 static object와 같은 것들을 관리하는 곳에 meta space라고 부름(과거에는 permanent area라고 불렀었음)

- method area (== class area)

class metadata

- pc register (pc)
- native stack (c 또는 c++ 코드를 불러와서 관리하는 영역)

---

쓰레드는 톰캣이 알아서 만들어서 돌려주느라 우리가 인지하고 있진 않는데,
쓰레드에 대하여는 공부를 반드시 해야 하고 혼자 만들어 봐야 함

java 21에서는 가상 스레드가 추가되었음. 멀티코어를 자유롭게 사용할 수 있도록 새로운 기술이 발생하고 있는데, 이를 잘 이해하는 것이 매우 중요할 것임. (매우 핫 이슈임 - webflux 대용)

---
기본적으로 자바는 RMI를 지원함 (쓰레드)
기본적으로 자바 프로그램을 돌리면 약 15개 정도가 기본으로 돈다. (쓰레드 별로 스택이 있다는 걸 잊지 말자)
우리는 main thread를 잘 이해하는 것이 가장 우선이다.

메모리를 자꾸 그려야 함. (stack 과 heap, method area를 자연스럽게 이해하는)
-> polymolphism과 상속을 이해하기 위해서는 메모리를 잘 이해해야 함.

---
## 알고리즘
비트마스킹을 알면 고급 문제를 더 잘 풀게 된다. (나의 무기가 된다.)


---
무엇이든 계~속 꾸준히 자주 반복해서 "익숙"해지는게 중요하다. (반복이 중요함)


---
```java
Object o = new Object();
```
위와 같은 코드가 있을 때, heap에는 HashMap 객체가 하나 있다고 이해하면 되고, 그 해시맵 객체 안에 o의 해시코드와 힙 메모리 주소가 매핑되어 있어서, 사용자가 메모리 주소를 몰라도 힙에 저장된 실제 데이터를 조회할 수 있는 거라고 이해하면 된다.

근데 여기서 궁금했던 게, 객체의 해시코드는 절대적으로 유니크하진 않아서 이걸 어떻게 해결하나 했는데, jvm이 해시테이블의 키를 관리하면서 해시 충돌이 날 경우 해시 값을 재설정하는 것으로 대응하고 있다고 한다.

---

자바는 동적 언어이다. (이게 아주 중요하다)
- 자바는 클래스를 동적으로 로딩한다.	
	- jvm에는 실행중인 필요한 class 코드만 load된다. (변할 수 있으니까)
	- 따라서 (이론적으로) 자바는 서버를 종료하지 않고도 클래스를 변경하여 런타임에서 변경을 바로 반영할 수 있다. 왜냐? 클래스를 동적으로 로드하니까.
- 메모리 할당을 동적으로 한다.
- 메서드 바인딩(binding)을 동적으로 한다. [참고](https://hsik0225.github.io/java/2020/12/17/Static-Override/)
	- dynamic linking & dynamic binding 시점이 C++과 다르다. 왜냐? 자바는 클래스를 동적으로 로딩하니까. C++은 링킹을 컴파일 타임에 해 둔다. 자바는 컴파일 타임에 링킹을 못한다. 다이나믹하게 클래스를 로딩하니까. 자바는 static linking을 클래스 로딩때 한다. 그리고 메서드 호출때 dynamic linking이 일어난다. 따라서 자바에서는 static은 virtual invokation이 안된다. static은 클래스 로드할 때 링킹이 일어나므로 스태틱 메서드 오버라이딩은 의미가 없다. (`class A`와 `class subA extends A`가 있을 때, A의 static method인 hello()메서드와 이를 subA에서 hello()를 오버라이드 하여 재정의하여도 subA.hello()를 호출하면 A.hello()가 호출된다. 왜냐하면 정적 메서드는 클래스 로딩때 하니까.) 이렇게 동작하기 때문에 자바는 느리다. <- 객체지향을 구현하기 위해 다이나믹하게 구현하였다.
- 변화된 것을 바로바로 반영하기 위해 위처럼 만들었다. 기본적으로 JIT compiler를 통해 최적화를 진행한다 하더라도, 어느정도 느린 이유는 위처럼 동적으로 구현되어있기 때문이다.


자바 자료형
- 논리형
	- boolean : 1bit
- 문자형
	- char : 2 byte (16 bit) - `0` ~ `65535`
- 정수형
	- byte : 1 byte (8 bit)
	- short : 2 byte (16 bit) `-32,768` ~ `32,767`
	- int : 4 byte (32 bit)
	- long : 8 byte (64 bit)
- 실수형
	- float : 4 byte (32 bit)
	- double : 8 byte (64 bit) 
	- long이 float으로는 자동 형변환이 되는데, float은 long로 "자동"형변환은 안된다.
		-> 데이터 표현력을 기준으로 데이터 형변환 필요 유무를 따져라.
- 원시형 타입은 할당된 메모리 주소에 바로 그 값이 할당된다. 그리고 자료형에 따라 고정 메모리 크기를 차지한다.

- if 문 (생략)
- switch 문
	```java
  switch (expression) {
	  case val1:
		  statements;
		  break;
	  case val2:
	      statements;
		  break;
	  default:
	      statements;
	}
	```
	- 기본적으로는 정수형(int, byte, short, long)이어야 함
	- java 7 부터는 string도 가능
	- 비교 연산시에는 대소비교는 안되고, == 동등 비교만 됨.
	- val1, val2와 같이 case 옆에 있는 값은 무조건 상수여야 함. (비교 연산을 위해)

- 반복문
	- `for(int i = 0; i < arr.length; i++)` 가 있다고 할 때, arr.length를 접근하여 뽑아내는 건 `반복수 + 1` 만큼 한다. 즉, arr.length의 값이 10이면 11번 접근하고, 11번 비교하는 것이다.
	- for iteration 형태는 무조건 컬렉션을 전부 탐색해야 한다. 이는 전체 탐색에서는 최적화되어있기 때문에 일반적으로는 기본 for loop 보다는 빠르지만, 기본 basic loop는 range 설정이 자유로워서 이를 인지하여 선택적으로 사용하라.
	- 근데, 실제 개발에서는 stream()을 이용한 함수형 프로그래밍을 더 권장(가독성 높음)


## SSAFY 문제 클래스 이름 앙식
### SWEA
Solution_문제번호_수준_문제이름_이름

### 백준/정올
Main_문제번호_수준_문제이름_이름

### 공통사항
주석으로 다음 내용 안내
- 수행시간:
- 메모리 사용량:
- 간단 로직 요약: