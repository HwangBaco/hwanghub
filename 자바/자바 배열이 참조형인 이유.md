자바에서 배열은 참조 변수로 취급됩니다. 즉, 배열을 저장하는 변수는 메모리에 저장된 객체를 가리키는 주소 값을 갖는 변수입니다. 그렇다면 왜 자바는 배열을 이런 방식으로 구현했을까요? 이에 대한 이유를 살펴보도록 하겠습니다.

## 자바의 참조 타입

자바는 모든 객체를 힙(heap) 영역에 생성하고, 이들 객체에는 참조 변수를 통해 접근합니다. 이 참조 변수들은 스택(stack) 영역에 위치하며, 객체가 생성될 때 해당 객체를 가리키는 주소값을 갖게 됩니다. 여기에서 배열도 예외는 아닙니다. 배열 역시 객체로 취급되며, 배열을 선언하고 객체를 생성하면 해당 배열 객체를 가리키는 참조 변수가 생성됩니다.

```
int[] arr = new int[5];
```

위 코드에서 `arr`는 참조 변수로서, 생성된 배열 객체의 주소 값을 가리키게 됩니다. 배열은 물리적으로 연속된 공간에 데이터를 저장하는 방식이므로, 이 주소값이 나타내는 번지는 배열의 0번째 인덱스를 가리킵니다.

## 자바가 배열을 참조 변수로 취급하는 이유

자바가 배열을 참조 변수로 취급하는 가장 중요한 이유는 바로 자바의 메모리 관리 철학 때문입니다. 자바는 사용자가 메모리를 직접 조작하는 것을 방지하고 버그를 최소화하려는 의도로 포인터 개념을 제공하지 않습니다.

C++ 등의 언어는 배열을 기본형 데이터처럼 스택에 저장하여 빠르게 접근이 가능하지만, 자바는 배열을 객체처럼 취급하여 참조 변수를 통해 간접적으로 접근하게 됩니다. 이는 자바가 `pass by value` 방식으로 동작하고 포인터를 제공하지 않기 때문입니다. 따라서, 실제 메모리 주소 대신 참조 변수는 해시값을 가지며, 이를 통해 간접적으로 힙에 저장된 객체에 접근하여 데이터를 저장하고 사용합니다.

## 느리지만, 어쩔 수 없다.

참조 변수를 통해 배열에 접근하는 이 방식은 메모리 관리를 안정적으로 수행하고, 사용자가 메모리를 직접 조작하는 것으로 인한 버그를 방지하는 장점을 가지고 있습니다. 그러나 이 방식은 C++과 같이 스택을 통해 바로 값에 접근하지 않고, 힙 영역까지 들어가서 데이터를 확인해야 하므로 느리다는 단점은 있습니다. 하지만 어쩌겠어요. 자바가 포인터를 주기 싫다는데...