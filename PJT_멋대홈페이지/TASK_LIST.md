### 구현
- [x] 기본 CRUD API 구현 (...)
- [x] 대댓글 CRUD API 구현
- [x] 게시글 단일 상세 조회 API 구현
- [x] 정렬 기준 + 카테고리별 게시글 조회 API
- [x] 게시글 검색 조회 API (카테고리 구분 필요)
- [x] 게시글 목록 조회 main/sub category 필드 추가
- [x] 게시글 상세에서 main/sub category 필드 추가
- [x] 게시글 상세 response dto -> created date 필드 추가
- [x] 날짜형식 파싱해서 리턴 YYYY. (M)M. (D)D
- [x] 댓글별 로그인 유저가 좋아요를 눌렀는지 boolean 보내기 -> response 필드 추가
- [x] 로그인유저 댓글좋아요여부 boolean 필드 추가
- [ ] commentLike count 조회시에도 redis 사용하기? (이걸 하고싶으면 지금처럼 DB 중심으로 redis 를 업데이트 하는게 아니라, scheduler 방식으로 업데이트 하는게 필요할듯함)

### 트러블슈팅
- [x] 좋아요/댓글 생성 API 멱등성 구현
- [x] 게시글/댓글 수정/삭제 api 파라미터 postid/commentid로 수정
- [x] 게시글 조회 / 댓글 조회 api 분리하기 (기존에는 post 조회 api로 통합되어있었음)
- [v] createdDate 날짜 형식 체크 & 댓글 날짜형식 수정
- [x] 댓글 좋아요 post 요청 두번째 하면 400 뜸 (원래는 삭제되어야함) -> 멱등성 반영 완료
- [x] 카테고리 이름들 한글로 request될 수 있게 수정
- [x] 에러 잡기(PR날림 -> comment+post 조회 로직이 문제였고, 기존 코드를 변경하면서 문제가 생김; 기존 로직까지 매번 손으로 테스트하는게 점점 상당히 불편해짐, 테스트의 중요성을 느끼게 되는 계기)
- [x] 로직 수정에 따른 스키마 변경 -> DB 접속해서 postlike 에 createdDate, modifiedDate 칼럼 추가 SQL 실행하기
- [x] commentCount 로직 체크 (post 조회 부분)
- [x] 삭제된 댓글 두번 삭제 못하게 수정
- [x] redis commentCount 새로 set 할 때 count 쿼리에서 isDeleted = false인 것만 하도록 수정
- [ ] 삭제된 댓글에 대댓글 못달게 수정 (보류)
- [ ] servicedto 내부에서 controllerdto 등으로 변환하는 객체지향적 로직 구성


### 최적화
- [x] 게시글목록 api 최적화 : 커버링인덱스 적용
- [x] 게시글목록 api 최적화 : 레디스캐싱~좋아요/댓글수
- [x] postdetail 조회 api에 redis 적용 (count들)
- [x] business / presentation dto 분리
- [ ] 양방향 연관관계 편의메서드 설정시 발생하는 사이드이펙트(N+1가 발생한다던데 진짜인지) 확인~최적화 진행 : post <-> comment, postlike
- [ ] querydsl 쿼리 최적화 점검 (조회 api 전부)
ref) https://youtu.be/zMAX7g6rO_Y?si=dv4L-vgHb61JRxuN
- [ ] 게시글 본문슬라이싱 로직 수정(현재 비효율적)
- [ ] 테스트 커버리지 100% 구축 (커뮤니티 100%)
- [ ] PR 피드백 반영 (리팩토링, 성능 개선)
- [ ] 서비스 모니터링 환경 구축(grafana, prometheus)

- [ ] 기록하기
	1. 실무 프로젝트 프로세스 경험(화면정의서 받고 요구사항 정리, 기능명세서 작성하여 공유)
	2. 멀티모듈 설계 (멀티모듈이란, 사용 이유)
	3. 커버링 인덱스 사용하여 최적화 (로직 보여주기)
	4. Redis 적용하여 최적화 (로직 보여주기 + 아키텍처)
	5. servicedto, controllerdto 구분한 이유
	6. record를 dto에 적용한 이유
	7. 테스트코드 커버하기 + 리팩토링 진행 (AS-IS, TO-BE)

### 멋대 프로젝트에서 얻어갈 내용
1. **프로젝트 진행 방식** (화면정의서, 기능요구사항 paper 전달받아서 설계, 개발 진행 ; 요구되는 작업 단위로 커밋단위 설정 - 티켓과 유사)
2. **멀티모듈로 설계한 이유** : 확장성과 생산성 사이의 저울질 (MSA가 확장성은 당연히 좋겠지만, 들어가는 리소스 대비 현재 기획된 서비스의 비즈니스 사이즈로는 MSA는 오버엔지니어링이며, 이에 따라 생산성 저하 우려,
   하지만, 확장성을 포기할 수 없고, 코드 중복을 최소화하면서 체계적으로 확장해나갈 수 있는 멀티모듈 선택)
3. **자바 / 스프링을 선택한 이유** : 전부 학생이기 때문에 조금이라도 기존에 알고 있는 언어로 하는 것이 러닝커브도 적고, 생산성이 높을 것으로 판단함. 즉, 파이썬 vs 자바 였는데, 파이썬은 기본적으로 갖는 철학이 싱글스레드 기반이므로 어느정도 트래픽이 예정된 멋대 페이지는 자바로 결정. 자바 진영의 프레임워크 대표주자인 스프링 선택. (아울러 장고는 필요 없는 기능도 모두 자동으로 설치해야 하지만, 스프링은 생태계 조성이 잘 되어있어서 필요에 따라 추가도 가능하므로 스프링 선택)
4. **게시판 도메인을 담당하여 개발**
	1. CRUD : 기본 CRUD + 카테고리별 정렬 조회, 검색 조회
	2. 최적화 : 커버링인덱스 적용
	3. 최적화 : 레디스 적용하여 count ranking 구현
5. 개발시 중점 둔 것은 : 데드라인 내 구현 우선 + 이후 리팩토링을 통한 유지보수성 고려한 코드 작성 (관심사 분리, 느슨한 결합 등)

